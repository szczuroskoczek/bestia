---
title: "Core Concepts"
tldr: "Discover how BESTIA uses TypeScript decorators to define schema and commands, compiles them into a manifest, and manages dynamic data and migrations."
---

# Core Concepts

## TL;DR

BESTIA leverages a decorator-based approach in TypeScript to define your data models, commands, and queries. These definitions are compiled into a manifest (e.g., `.bestia-manifest`) which serves as the immutable source of truth. Dynamic data (snapshots, logs, indexes) is persisted alongside this manifest, with built-in migration logic ensuring consistency as your schema evolves.

## Schema Definition

Use TypeScript decorators to declare models and their behavior. For example:

```typescript
class User extends BestiaModel {
  @B_UUID()         // Auto-generate UUID for the user.
  @B$Index()        // Mark as an indexed field.
  id: string;

  @B_String({ required: ['insert'] })
  username: string;

  @B_String({ required: ['insert'] })
  password: string;  // Initially stores plain text; later migrated to hashed.
}
```

## Compiled Artifacts

- **Manifest File (.bestia-manifest):**  
  Contains the immutable definitions (schema, commands, queries) generated by the BESTIA compiler.
- **Dynamic Data:**  
  Includes snapshots, logs, and indexes maintained by the BESTIA engine.

## Command & Query Model

Define commands and queries as classes extending `BestiaCommand` or `BestiaQuery`. For example:

```typescript
class CreateUser extends BestiaCommand {
  execute(@Body(User.dto.create) data: Partial<User>) {
    // Business logic to create a user.
    return User.create(data);
  }
}
```

This model enables a unified interface for both mutations and queries.

[Learn About Migrations](migrations.md)