---
title: "Core Concepts"
tldr: "Discover how BESTIA uses TypeScript decorators to define your schema and operations, compiling them into a manifest for seamless deployment and migration."
---

# Core Concepts

## TL;DR

BESTIA uses a decorator-based approach in TypeScript to define your data models and operations. These definitions are compiled into a **BESTIA Manifest** (e.g., `.bestia-manifest`), which serves as the immutable blueprint of your application's schema, queries, and actions. The runtime engine then manages dynamic data (snapshots, logs, indexes) and applies migrations as needed.

## Schema Definition

Define your data models using intuitive TypeScript decorators. For example:

```typescript
import { B_UUID, B_Index, B_String, B_Date } from "bestia-decorators";

export class User extends BestiaModel {
  @B_UUID() // Automatically generates a UUID.
  @B_Index() // Marks this field for indexing.
  id: string;

  @B_String({ required: ["create"] })
  username: string;

  // Initially, password is stored as plain text (to be migrated to hashed later)
  @B_String({ required: ["create"] })
  password: string;

  @B_Date({ required: ["update"] })
  updatedAt: Date;
}
```

The decorators capture metadata that is later used to generate the manifest and to validate data at runtime.

## Compiling the BESTIA Manifest

The **BESTIA Manifest** is generated by the BESTIA Compiler. It encapsulates:

- The immutable schema definitions and metadata.
- Versioning information.
- Definitions for operations (both Queries and Actions).

This manifest is stored in a file (e.g., `.bestia-manifest`), which becomes the single source of truth for your applicationâ€™s structure.

## Operation Model: Queries & Actions

BESTIA distinguishes between:

- **Queries:** Read-only operations for retrieving data.
- **Actions:** Operations that change state (replacing the traditional "mutations" or "commands").

### Query Example

Define a query to fetch user data:

```typescript
export class GetUserDataQuery extends BestiaQuery {
  execute(params: { id: string }): User | null {
    // Retrieve a user record by ID.
    return User.findOne({ id: params.id });
  }
}
```

### Action Example

Define an action to create a new user:

```typescript
export class CreateUserAction extends BestiaAction {
  execute(@Payload(User.schema.create) data: Partial<User>): User {
    // Business logic for user creation.
    // This might include validation and transformation.
    return User.create(data);
  }
}
```

This model enables a unified interface for both mutations and queries.

[Learn About Migrations](migrations.md)
